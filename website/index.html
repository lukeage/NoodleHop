<!DOCTYPE html>
<html>
<head>
    <title>Noodle Hop</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #74ebd5, #ACB6E5);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Fredoka One', cursive;
        }
        
        #game-container {
            position: relative;
            width: 420px;
            height: 620px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        #game {
            width: 400px;
            height: 600px;
            background: linear-gradient(180deg, #c9f5ff 0%, #a1e8ff 100%);
            position: relative;
            overflow: hidden;
            margin: 10px;
            border-radius: 10px;
        }
        
        #player {
            width: 60px;
            height: 60px;
            position: absolute;
            bottom: 100px;
            left: 175px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%233DB2FF"/><circle cx="35" cy="40" r="10" fill="white"/><circle cx="65" cy="40" r="10" fill="white"/><circle cx="35" cy="40" r="5" fill="black"/><circle cx="65" cy="40" r="5" fill="black"/><path d="M30 65 Q50 80 70 65" stroke="black" stroke-width="5" fill="none"/></svg>');
            background-size: contain;
            z-index: 10;
            transition: transform 0.1s;
        }
        
        .platform {
            width: 80px;
            height: 15px;
            position: absolute;
            border-radius: 10px;
        }
        
        .platform-normal {
            background: linear-gradient(180deg, #9EE37D 0%, #63C132 100%);
            box-shadow: 0 3px 0 #48841F;
        }
        
        .platform-breakable {
            background: linear-gradient(180deg, #FF9A8B 0%, #FF6B6B 100%);
            box-shadow: 0 3px 0 #C53030;
        }
        
        .platform-horizontal {
            background: linear-gradient(180deg, #90CAF9 0%, #42A5F5 100%);
            box-shadow: 0 3px 0 #1976D2;
        }
        
        .platform-vertical {
            background: linear-gradient(180deg, #FFCC80 0%, #FFA726 100%);
            box-shadow: 0 3px 0 #FB8C00;
        }
        
        .platform-break {
            animation: break-platform 0.3s forwards;
        }
        
        @keyframes break-platform {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.5); opacity: 0; }
        }
        
        .cloud {
            position: absolute;
            opacity: 0.7;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 50"><path d="M10 40 Q15 20 40 30 Q50 5 70 20 Q85 10 90 30 Q100 35 90 40 L10 40 Z" fill="white"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
        }
        
        #score {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            color: #333;
            text-shadow: 2px 2px 0px rgba(255,255,255,0.5);
        }
        
        #title {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 22px;
            color: #333;
            text-shadow: 2px 2px 0px rgba(255,255,255,0.5);
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes floating {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        
        .bounce {
            animation: bounce 0.3s;
        }
        
        #game-over {
            position: absolute;
            width: 300px;
            height: 200px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        #game-over h2 {
            color: #333;
            margin-bottom: 10px;
        }
        
        #restart-btn {
            background: #FF6B6B;
            color: white;
            border: none;
            padding: 10px 20px;
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        
        #restart-btn:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game">
            <div id="player"></div>
            <div id="score">0</div>
            <div id="title">Doodle Jump</div>
        </div>
        <div id="game-over">
            <h2>Game Over!</h2>
            <div id="final-score">Score: 0</div>
            <button id="restart-btn">Play Again</button>
        </div>
    </div>

    <script>
        const game = document.getElementById('game');
        const player = document.getElementById('player');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');
        
        let platforms = [];
        let clouds = [];
        let gameStarted = false;
        let playerX = 175;
        let playerY = 300;
        let velocityY = 0;
        let gravity = 0.4;
        let score = 0;
        let gameWidth = 400;
        let gameHeight = 600;
        let jumping = false;
        let gameOver = false;
        
        // Platform types
        const PLATFORM_TYPES = {
            NORMAL: 'normal',
            BREAKABLE: 'breakable',
            HORIZONTAL: 'horizontal',
            VERTICAL: 'vertical'
        };
        
        // Create clouds for background
        function createClouds() {
            for (let i = 0; i < 5; i++) {
                createCloud();
            }
        }
        
        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            const size = 50 + Math.random() * 50;
            const x = Math.random() * gameWidth;
            const y = Math.random() * gameHeight;
            
            cloud.style.width = size + 'px';
            cloud.style.height = size/2 + 'px';
            cloud.style.left = x + 'px';
            cloud.style.top = y + 'px';
            cloud.style.animation = `floating ${3 + Math.random() * 4}s infinite ease-in-out`;
            
            game.appendChild(cloud);
            
            clouds.push({
                element: cloud,
                x: x,
                y: y,
                speed: 0.2 + Math.random() * 0.3
            });
        }
        
        // Create initial platforms
        function createPlatforms() {
            // Start with a normal platform under the player
            platforms.push({
                x: 150,
                y: 400,
                type: PLATFORM_TYPES.NORMAL,
                element: createPlatformElement(150, 400, PLATFORM_TYPES.NORMAL),
                direction: 1,
                speed: 0
            });
            
            // Create more platforms with guaranteed path upward
            for (let i = 0; i < 10; i++) {
                // For the first few platforms, ensure they're spaced for easy jumping
                // Start closer to center, then spread out more
                let x;
                if (i < 3) {
                    // First few platforms near center but with slight randomness
                    x = gameWidth/2 - 40 + (Math.random() * 80 - 40);
                } else {
                    // Gradually increase randomness as we go higher
                    const spreadFactor = Math.min(1, i / 5); // Gradually increase from 0 to 1
                    x = gameWidth/2 - 40 + (Math.random() * gameWidth * spreadFactor - (gameWidth * spreadFactor / 2));
                }
                
                // Constrain to game boundaries
                x = Math.max(0, Math.min(gameWidth - 80, x));
                let y = i * 60;
                
                // First 5 platforms are always normal for easier start
                let type = (i < 5) ? PLATFORM_TYPES.NORMAL : PLATFORM_TYPES.NORMAL;
                
                // After first 5, introduce some variety based on randomness
                if (i >= 5) {
                    let platformChance = Math.random();
                    if (platformChance < 0.2) {
                        type = PLATFORM_TYPES.HORIZONTAL;
                    } else if (platformChance < 0.3) {
                        type = PLATFORM_TYPES.VERTICAL;
                    }
                    // No breakable platforms in initial setup
                }
                
                // For moving platforms, set speed and direction
                let speed = 0;
                let direction = 1;
                
                if (type === PLATFORM_TYPES.HORIZONTAL) {
                    speed = 1 + Math.random() * 2;
                    direction = Math.random() < 0.5 ? 1 : -1;
                } else if (type === PLATFORM_TYPES.VERTICAL) {
                    speed = 1 + Math.random() * 1.5;
                    direction = Math.random() < 0.5 ? 1 : -1;
                }
                
                platforms.push({
                    x: x,
                    y: y,
                    type: type,
                    element: createPlatformElement(x, y, type),
                    direction: direction,
                    speed: speed,
                    startY: y // For vertical platforms
                });
            }
        }
        
        function createPlatformElement(x, y, type) {
            const platform = document.createElement('div');
            platform.className = 'platform';
            
            // Add specific class based on platform type
            switch (type) {
                case PLATFORM_TYPES.NORMAL:
                    platform.classList.add('platform-normal');
                    break;
                case PLATFORM_TYPES.BREAKABLE:
                    platform.classList.add('platform-breakable');
                    break;
                case PLATFORM_TYPES.HORIZONTAL:
                    platform.classList.add('platform-horizontal');
                    break;
                case PLATFORM_TYPES.VERTICAL:
                    platform.classList.add('platform-vertical');
                    break;
            }
            
            platform.style.left = x + 'px';
            platform.style.top = y + 'px';
            game.appendChild(platform);
            return platform;
        }
        
        // Handle mouse movement
        game.addEventListener('mousemove', (e) => {
            if (!gameOver) {
                // Calculate mouse position relative to game container
                const rect = game.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                // Set player position, keeping within boundaries
                playerX = Math.max(0, Math.min(gameWidth - 60, mouseX - 30));
                player.style.left = playerX + 'px';
            }
        });
        
        // Move clouds
        function updateClouds() {
            for (let i = 0; i < clouds.length; i++) {
                clouds[i].y += clouds[i].speed;
                
                if (clouds[i].y > gameHeight) {
                    clouds[i].y = -50;
                    clouds[i].x = Math.random() * gameWidth;
                }
                
                clouds[i].element.style.top = clouds[i].y + 'px';
            }
        }
        
        // Update platform positions for moving platforms
        function updatePlatforms() {
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                
                // Update horizontal platforms
                if (platform.type === PLATFORM_TYPES.HORIZONTAL) {
                    platform.x += platform.speed * platform.direction;
                    
                    // Change direction if platform hits the edge
                    if (platform.x <= 0 || platform.x >= gameWidth - 80) {
                        platform.direction *= -1;
                    }
                    
                    platform.element.style.left = platform.x + 'px';
                }
                
                // Update vertical platforms
                if (platform.type === PLATFORM_TYPES.VERTICAL) {
                    // Move up and down within a range of 50px
                    platform.y += platform.speed * platform.direction;
                    
                    // Change direction at the extremes
                    if (platform.y >= platform.startY + 50 || platform.y <= platform.startY - 50) {
                        platform.direction *= -1;
                    }
                    
                    platform.element.style.top = platform.y + 'px';
                }
            }
        }
        
        // Create a new platform
        function createNewPlatform() {
            let x = 0;
            let y = -20;
            
            // Define jump capabilities
            const maxHorizontalJump = 150;
            const maxJumpHeight = 200; // Maximum height player can jump
            const minVerticalGap = 50;  // Minimum gap between platforms vertically
            const maxVerticalGap = 120; // Maximum vertical gap that's still reachable
            const minOffset = 30; // Minimum horizontal distance
            const maxOffset = Math.min(maxHorizontalJump, 140); // Maximum horizontal distance
            
            // Find the highest platform currently in game
            const highestPlatform = platforms.reduce((highest, current) => 
                (current.y < highest.y) ? current : highest, {y: Infinity});
            
            if (highestPlatform && highestPlatform.y !== Infinity) {
                // Ensure vertical distance is reasonable
                y = Math.max(-20, highestPlatform.y - (minVerticalGap + Math.random() * (maxVerticalGap - minVerticalGap)));
                
                // 80% chance to place within jump range of highest platform
                if (Math.random() < 0.8) {
                    const horizontalOffset = (Math.random() < 0.5) ? 
                        -minOffset - Math.random() * (maxOffset - minOffset) :  // Left
                         minOffset + Math.random() * (maxOffset - minOffset);   // Right
                    
                    x = Math.max(0, Math.min(gameWidth - 80, highestPlatform.x + horizontalOffset));
                } else {
                    // For the other 20%, still ensure platform is reachable from somewhere
                    x = Math.random() * (gameWidth - 80);
                    
                    // Check if the new platform is reachable from any top platforms
                    const topPlatforms = platforms.filter(p => 
                        p.y < y + maxJumpHeight && 
                        p.y > y && 
                        p.type !== PLATFORM_TYPES.BREAKABLE // FIXED: Exclude breakable platforms
                    );
                    
                    // If no platform can reach it, adjust position
                    if (!topPlatforms.some(p => Math.abs(p.x - x) < maxHorizontalJump)) {
                        // Choose a random top platform to place near
                        if (topPlatforms.length > 0 && !topPlatforms.some(p => Math.abs(p.x - x) < maxHorizontalJump)) {
                            const referencePlatform = topPlatforms[Math.floor(Math.random() * topPlatforms.length)];
                            x = referencePlatform.x + (Math.random() * 80 - 40);
                            x = Math.max(0, Math.min(gameWidth - 80, x)); // Keep within boundaries
                        } else {
                            // Fallback to place near highest
                            x = Math.max(0, Math.min(gameWidth - 80, highestPlatform.x + (Math.random() * 100 - 50)));
                        }
                    }
                }
            } else {
                // If no platforms exist yet, place in middle
                x = gameWidth/2 - 40;
            }
            
            // Choose platform type based on score and randomness
            let type = PLATFORM_TYPES.NORMAL;
            let platformChance = Math.random();
            
            // Get the 3 most recent platforms created (likely at the top of the screen)
            const recentPlatforms = [...platforms].sort((a, b) => a.y - b.y).slice(0, 3);
            const recentBreakable = recentPlatforms.filter(p => p.type === PLATFORM_TYPES.BREAKABLE).length;
            
            // If too many recent breakable platforms, force this one to be normal
            if (recentBreakable >= 2) {
                type = PLATFORM_TYPES.NORMAL;
            } else {
                // Standard platform type selection
                if (score > 300) {
                    if (platformChance < 0.25 && recentBreakable < 2) {
                        type = PLATFORM_TYPES.BREAKABLE;
                    } else if (platformChance < 0.5) {
                        type = PLATFORM_TYPES.HORIZONTAL;
                    } else if (platformChance < 0.75) {
                        type = PLATFORM_TYPES.VERTICAL;
                    }
                } else if (score > 150) {
                    if (platformChance < 0.2 && recentBreakable < 2) {
                        type = PLATFORM_TYPES.BREAKABLE;
                    } else if (platformChance < 0.4) {
                        type = PLATFORM_TYPES.HORIZONTAL;
                    } else if (platformChance < 0.6) {
                        type = PLATFORM_TYPES.VERTICAL;
                    }
                } else if (score > 50) {
                    if (platformChance < 0.1 && recentBreakable < 1) {
                        type = PLATFORM_TYPES.BREAKABLE;
                    } else if (platformChance < 0.2) {
                        type = PLATFORM_TYPES.HORIZONTAL;
                    } else if (platformChance < 0.3) {
                        type = PLATFORM_TYPES.VERTICAL;
                    }
                }
            }
            
            // For early game (first 10 platforms), keep them all normal for easier start
            if (score < 30) {
                type = PLATFORM_TYPES.NORMAL;
            }
            
            // For moving platforms, set speed and direction
            let speed = 0;
            let direction = 1;
            
            if (type === PLATFORM_TYPES.HORIZONTAL) {
                speed = 1 + Math.random() * 2;
                direction = Math.random() < 0.5 ? 1 : -1;
            } else if (type === PLATFORM_TYPES.VERTICAL) {
                speed = 1 + Math.random() * 1.5;
                direction = Math.random() < 0.5 ? 1 : -1;
            }
            
            // Before finalizing, double-check reachability one more time
            const topPlatforms = platforms.filter(p => 
                p.y < y + maxJumpHeight && p.y > y
            );
            
            // If truly unreachable, adjust position to be near a random top platform
            if (topPlatforms.length > 0 && !topPlatforms.some(p => Math.abs(p.x - x) < maxHorizontalJump)) {
                const referencePlatform = topPlatforms[Math.floor(Math.random() * topPlatforms.length)];
                x = referencePlatform.x + (Math.random() * 80 - 40);
                x = Math.max(0, Math.min(gameWidth - 80, x)); // Keep within boundaries
            }
            
            let newPlatform = {
                x: x,
                y: y,
                type: type,
                element: createPlatformElement(x, y, type),
                direction: direction,
                speed: speed,
                startY: y
            };
            
            platforms.push(newPlatform);
            return newPlatform;
        }

        function isIsolatedPosition(x) {
            // Maximum horizontal jump distance
            const maxJumpDistance = 150;
            
            // Check against platforms in upper area of screen
            // FIXED: Filter out breakable platforms
            const topPlatforms = platforms.filter(p => 
                p.y < 150 && 
                p.type !== PLATFORM_TYPES.BREAKABLE // Exclude breakable platforms
            );
            
            // If there are no top platforms, this isn't isolated (it's the first one)
            if (topPlatforms.length === 0) return false;
            
            // Check if any platform is within jumping range
            for (const platform of topPlatforms) {
                // Calculate horizontal distance between platforms
                const horizontalDistance = Math.abs(platform.x - x);
                
                // If within jump range, not isolated
                if (horizontalDistance < maxJumpDistance) {
                    return false;
                }
            }
            
            // If we get here, the position is isolated
            return true;
        }
        
        // Game logic
        function update() {
            if (gameOver) return;
            
            // Update clouds
            updateClouds();
            
            // Update moving platforms
            updatePlatforms();
            
            // Apply gravity to player
            velocityY += gravity;
            playerY += velocityY;
            
            // Check if player is falling
            if (velocityY < 0) {
                // Moving upward
                jumping = true;
                player.style.transform = 'scaleY(0.9)';
            } else {
                // Falling down
                jumping = false;
                player.style.transform = 'scaleY(1)';
                
                // Check for collisions with platforms
                for (let i = 0; i < platforms.length; i++) {
                    const platform = platforms[i];
                    
                    // Check if player is on a platform
                    if (playerY + 55 >= platform.y && 
                        playerY + 55 <= platform.y + 15 && 
                        playerX + 45 >= platform.x && 
                        playerX + 15 <= platform.x + 80 && 
                        velocityY > 0) {
                        
                        // Handle different platform types
                        if (platform.type === PLATFORM_TYPES.BREAKABLE) {
                            // Breakable platform - break and remove
                            platform.element.classList.add('platform-break');
                            
                            setTimeout(() => {
                                if (platform.element && platform.element.parentNode) {
                                    game.removeChild(platform.element);
                                }
                                
                                const index = platforms.indexOf(platform);
                                if (index > -1) {
                                    platforms.splice(index, 1);
                                    createNewPlatform();
                                }
                            }, 300);
                            
                            // Don't bounce on breakable platforms
                            continue;
                        } else {
                            // Bounce on other platform types
                            velocityY = -12;
                            jumping = true;
                            
                            // Add bounce animation
                            platform.element.classList.add('bounce');
                            
                            // Remove normal (green) platforms after jumping on them
                            if (platform.type === PLATFORM_TYPES.NORMAL) {
                                platform.element.classList.add('platform-break');
                                
                                setTimeout(() => {
                                    if (platform.element && platform.element.parentNode) {
                                        game.removeChild(platform.element);
                                    }
                                    
                                    const index = platforms.indexOf(platform);
                                    if (index > -1) {
                                        platforms.splice(index, 1);
                                        createNewPlatform();
                                    }
                                }, 300);
                            } else {
                                // For other non-breakable platforms, just remove the bounce animation
                                setTimeout(() => {
                                    if (platform.element && platform.element.classList) {
                                        platform.element.classList.remove('bounce');
                                    }
                                }, 300);
                            }
                        }
                        break;
                    }
                }
            }
            
            // Allow player to wrap around screen horizontally
            if (playerX < -60) {
                playerX = gameWidth;
            } else if (playerX > gameWidth) {
                playerX = -60;
            }
            
            // Game over if player falls off the bottom
            if (playerY > gameHeight) {
                endGame();
                return;
            }
            
            // Move camera/view - when player gets high enough
            if (playerY < 300) {
                // Move platforms down
                let offset = 300 - playerY;
                playerY = 300;
                
                for (let i = 0; i < platforms.length; i++) {
                    platforms[i].y += offset;
                    platforms[i].element.style.top = platforms[i].y + 'px';
                    
                    // For vertical platforms, also update the start position
                    if (platforms[i].type === PLATFORM_TYPES.VERTICAL) {
                        platforms[i].startY += offset;
                    }
                    
                    // Remove platforms that are off the bottom of the screen
                    if (platforms[i].y > gameHeight) {
                        // First remove the element from the DOM
                        if (platforms[i].element && platforms[i].element.parentNode) {
                            game.removeChild(platforms[i].element);
                        }
                        
                        // Then remove from the array
                        platforms.splice(i, 1);
                        i--; // Adjust the index after splicing
                        
                        // Add a new platform at the top
                        createNewPlatform();
                        
                        // Increase score
                        score += 10;
                        scoreDisplay.textContent = score;
                    }
                }
                
                // Move clouds too
                for (let i = 0; i < clouds.length; i++) {
                    clouds[i].y += offset * 0.5; // Clouds move at half speed for parallax effect
                    clouds[i].element.style.top = clouds[i].y + 'px';
                }
            }
            
            // Update player position
            player.style.top = playerY + 'px';
            player.style.left = playerX + 'px';
            
            requestAnimationFrame(update);
        }
        
        function endGame() {
            gameOver = true;
            finalScoreDisplay.textContent = `Score: ${score}`;
            gameOverScreen.style.display = 'flex';
        }
        
        // Restart game
        restartBtn.addEventListener('click', () => {
            // Clear all platforms and clouds
            platforms.forEach(platform => {
                if (platform.element && platform.element.parentNode) {
                    game.removeChild(platform.element);
                }
            });
            
            clouds.forEach(cloud => {
                if (cloud.element && cloud.element.parentNode) {
                    game.removeChild(cloud.element);
                }
            });
            
            // Reset arrays
            platforms = [];
            clouds = [];
            
            // Reset variables
            playerX = 175;
            playerY = 300;
            velocityY = 0;
            score = 0;
            gameOver = false;
            
            // Reset UI
            player.style.top = playerY + 'px';
            player.style.left = playerX + 'px';
            scoreDisplay.textContent = '0';
            gameOverScreen.style.display = 'none';
            
            // Start game again
            startGame();
        });
        
        // Start the game
        function startGame() {
            createClouds();
            createPlatforms();
            gameStarted = true;
            update();
        }
        
        startGame();
    </script>
</body>
</html>